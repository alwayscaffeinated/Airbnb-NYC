# -*- coding: utf-8 -*-
"""NYC AirBnB.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vqW5Y4yBHOAGt-McSm0HOmpfElCxFP8G
"""

import plotly.offline as pyoff
import plotly.graph_objs as go
import plotly.express as px
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib
import warnings
import math
import gc
import plotly as pl
warnings.filterwarnings('ignore')

from google.colab import drive
drive.mount('/content/drive')

data = pd.read_csv('/content/drive/My Drive/AB_NYC_2019.csv')

data.head()

data.isnull().sum() / len(data) *100

data.describe()

data = data[data['price'] != 0.000000]

data.describe()

data.rename(columns = {'neighbourhood_group':'borough'},inplace=True)

data.head()

"""


*   The price of listing price starts from 10 USD and goes as high as  $10000 USD.

Lets dive in a little deeper to see how the location affects the price

"""

borough_room = pd.DataFrame(data.groupby(['borough','room_type'])['room_type'].count().unstack().reset_index())
borough_room

home = (np.sum(borough_room['Entire home/apt']) / (np.sum(borough_room['Entire home/apt']) + np.sum(borough_room['Private room']) + np.sum(borough_room['Shared room']) ) ) * 100
private = (np.sum(borough_room['Private room']) / (np.sum(borough_room['Entire home/apt']) + np.sum(borough_room['Private room']) + np.sum(borough_room['Shared room']) ) ) * 100
shared = (np.sum(borough_room['Shared room']) / (np.sum(borough_room['Entire home/apt']) + np.sum(borough_room['Private room']) + np.sum(borough_room['Shared room']) ) ) * 100

new_df = pd.DataFrame()
new_df['Accomodation type'] = ['Entire home/apt', 'Private room', 'Shared room']
new_df['Availibility'] = [home, private, shared]
new_df

fig_pie = px.pie(new_df, values =  'Availibility', names = 'Accomodation type', title = 'Distribution of accomodation type in NYC')
fig_pie.show()

borough_room_columns = list(borough_room.columns)[1:]

borough_room_long = borough_room.melt(id_vars = ['borough'], value_vars = borough_room_columns, var_name= 'Room Type', value_name = 'Count of Rooms')

borough_room_long.head()

px.bar(borough_room_long,
      x = 'borough',
      y = 'Count of Rooms',
      color = 'Room Type',
      barmode='group',
      template ='plotly_white',
      title = {
          'text':'Borough wise accomodation analysis',
          'x':0.5,
          'y':0.85
        
      },
      labels={
          'borough':'Borough',
           "Count of Rooms": "No. of Availabilities",
          'Room Type':'Accomodation Type'
           
       }
      )

borough_room

borough_room_percent = borough_room.copy()

borough_room_percent['Entire home/apt'] = (borough_room_percent['Entire home/apt'] /np.sum(borough_room_percent['Entire home/apt'])) *100
borough_room_percent['Private room'] = (borough_room_percent['Private room'] /np.sum(borough_room_percent['Private room'])) *100
borough_room_percent['Shared room'] = (borough_room_percent['Shared room'] /np.sum(borough_room_percent['Shared room'])) *100

borough_room_percent

borough_room_percent_long = borough_room_percent.melt(id_vars = ['borough'], value_vars = borough_room_columns, var_name= 'Room Type', value_name = 'Percent of Rooms')

borough_room_percent_long

px.bar(borough_room_percent_long,
      x = 'borough',
      y = 'Percent of Rooms',
      color = 'Room Type',
      barmode='group',
      template ='plotly_white',
      title = {
          'text':'Borough wise accomodation analysis',
          'x':0.5,
          'y':0.85
        
      },
      labels={
          'borough':'Borough',
           "Count of Rooms": "No. of Availabilities",
          'Room Type':'Accomodation Type'

           
       }
      )

borough_median_price = data.groupby('borough').agg({'price': pd.Series.median}).unstack().reset_index()

borough_median_price =  borough_median_price.iloc[:,[1,2]]
borough_median_price.rename(columns = {0:'Median Price'}, inplace = True)

borough_median_price

borough_mean_price = data.groupby('borough').agg({'price': pd.Series.mean}).unstack().reset_index()

borough_mean_price =  borough_mean_price.iloc[:,[1,2]]
borough_mean_price.rename(columns = {0:'Average Price'}, inplace = True)

borough_mean_price

trace_price1 = go.Bar(x = borough_mean_price['borough'],
                      y = borough_mean_price['Average Price'],
                      name = 'Average price',
                      marker = dict(color='#A2D5F2'))

trace_price2 = go.Bar(x = borough_median_price['borough'],
                      y = borough_median_price['Median Price'],
                      name = 'Median Price')

data_price = [trace_price1, trace_price2]

layout = go.Layout(barmode = 'group',
                   title = 'Average and Median pricing for per night rental')
fig = go.Figure(data = data_price, layout = layout)
fig.show()

"""Living around Manhattan and Brooklyn is expensive"""

borough_room_type = data.groupby(['borough', 'room_type']).agg({'price': pd.Series.median}).reset_index()

borough_room_type

px.bar(borough_room_type,
       x = 'borough',
       y = 'price',
       color = 'room_type',
       barmode = 'group',
       title = 'Median pricing for various accomodation types in NYC boroughs',
       
       labels = {'borough': 'Boroughs',
                 'price': 'Median price',
                 'room_type': 'Accomodation type'}
       )

x = data['latitude']
y = data['longitude']
price = data['price']
plt.figure(figsize = (20,10))
plt.scatter(x,y, c = price)
plt.colorbar()
plt.title('Variation of listing price')
plt.xlabel('latitude')
plt.ylabel('longitude')
plt.legend()
plt.show()

plt.figure(figsize=(10,5))
sns.distplot(data['price'], bins=100)
plt.xlabel('Price')
plt.ylabel('frequency')
plt.show()

"""Log transformation needs to be performed as price is rightly skewed"""

data['log price'] = np.log(data['price'])

plt.figure(figsize=(10,5))
sns.distplot(data['log price'], bins=100)
plt.show()

"""Post log transformation, price seems to be somewhat normally distributed"""

#getting numeric columns
numeric = data.select_dtypes(include = np.number).columns.tolist()
numeric

#droping id columns
numeric = numeric[2:]

len(numeric)

fig, axes = plt.subplots(3,3,figsize= (20,15))
axes = axes.flatten()
for i,ax in enumerate(axes):
  ax.hist(data[numeric[i]])
  ax.set_xlabel(numeric[i])
  ax.set_ylabel('Frequency')
  ax.set_title(numeric[i])
plt.show()

numeric.remove('price')

numeric[2:-1]

data.isnull().sum() / len(data) *100

data['last_review'].mode()

data['last_review'].fillna('2019-06-23',inplace=True)
data['last_review'].isnull().sum()

data['reviews_per_month'].mode()

data['reviews_per_month'].fillna('0.02', inplace=True)
data['reviews_per_month'].isnull().sum()

data['last_review'] = pd.to_datetime(data['last_review'])
data['reviews_per_month'] = np.array(data['reviews_per_month']).astype(float)

for i in numeric[2:-1]:
  data['log ' + i] = np.log(data[i]+1)

data.head()

numeric

for i in numeric[2:-1]:
  data.drop(i,1,inplace=True)

data.head()

#One hot encoding the categorical variables
bor = pd.get_dummies(data['borough'])
neigh = pd.get_dummies(data['neighbourhood'])

data = pd.concat([data, bor],1)

data.head()

"""Outlier detection and removal if it exists"""

sns.boxplot(data['log price'])

room_type = list(set(data['room_type']))
for i in room_type:
  new = data[data['room_type'] == i]
  sns.boxplot(new['log price'])
  plt.title(i)
  plt.show()

def remove_outlier(dataframe, room_type):
  new = dataframe[dataframe['room_type'] == room_type]
  Q1 = new['log price'].quantile(0.25)
  Q3 = new['log price'].quantile(0.75)
  IQR = Q3 - Q1
  filter = (new['log price'] >= (Q1 - (1.5 * IQR))) & (new['log price'] <= (Q3 + (1.5 * IQR)))
  return new.loc[filter]

print(set(data['room_type']))

shared_price = remove_outlier(data,'Shared room')
print('Outliers removed: ', len(data[data['room_type'] == 'Shared room']) - len(shared_price))

entire_home_price = remove_outlier(data,'Entire home/apt')
print('Outliers removed: ', len(data[data['room_type'] == 'Entire home/apt']) - len(entire_home_price))

private_price = remove_outlier(data,'Private room')
print('Outliers removed: ', len(data[data['room_type'] == 'Private room']) - len(private_price))

new_data = pd.DataFrame()
new_data = new_data.append([private_price, entire_home_price, shared_price])

print('Total outliers removed: ', len(data)- len(new_data))

new_data.head()

from xgboost import XGBRFRegressor
from sklearn.tree import DecisionTreeRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import f1_score,accuracy_score

new_data.drop('price',1, inplace=True)

room_onehot = pd.get_dummies(new_data['room_type'])
new_data = pd.concat([new_data, room_onehot],1)

new_data.head()

latitude = new_data['latitude']
longitude = new_data['longitude']
new_data.drop(['longitude', 'latitude'],1,inplace=True)
new_data['latitude'] = latitude
new_data['longitude'] = longitude
new_data.head()

neighbour = pd.get_dummies(new_data['neighbourhood'])
new_data = pd.concat([new_data, neighbour], 1)

new_data.head()

X = new_data.iloc[:, 10:]
y = new_data['log price']



X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 6)

tree = DecisionTreeRegressor()
tree.fit(X_train,y_train)
y_pred = tree.predict(X_test)

tree_score = tree.score(X_test, y_test)
tree_score

from sklearn.metrics import mean_squared_error

rm = mean_squared_error(y_test, y_pred)

rm

xgb = XGBRFRegressor()
xgb.fit(X_train,y_train)

xgb_score = xgb.score(X_test, y_test)
xgb_score

from sklearn.ensemble import RandomForestRegressor

random_forest = RandomForestRegressor()
random_forest.fit(X_train, y_train)

random_score = random_forest.score(X_test, y_test)
random_score

